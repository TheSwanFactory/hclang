
Title         : Homoiconic C
Subtitle      : Programming without a Language

HideAuthor        : Ernest N. Prabhakar
HideAffiliation   : The Swan Factory, Inc.
HideEmail         : ernest.prabhakar@gmail.com

Bib style     : plainnat
Bibliography  : hc-refs.bib
Logo          : True
Package       : amsmath
Doc class     : [preprint]{sigplanconf}

Colorizer     : ruby
~Pre,~Code    : language=ruby
.pre-indented : language=ruby

[TITLE]

~ Abstract

Modern programming is dominated by languages derived from C[@CLang] and
the UNIX shell[@UNIXShell], characterized by complicated syntax and
sophisticated parsers. Minimalist languages such as Forth[@Forth],
Scheme[@Scheme] and Self[@Self] are no longer taken seriously[^lua-fn],
presumably because they are felt to lack sufficiently readable _syntax_
and powerful enough _semantics_.

In this paper we introduce a novel data format called **Homoiconic C**
("HC") that we claim expresses a safe superset of C-like computations,
yet is even easier to read than existing scripting languages. The key is
a novel data structure and computational model we call _Frames_, designed
to replace and improve upon the s-expressions and metacircular evaluation
model of Lisp[@Lisp]. Frames act as a universal monad[^monad], with the
result that Homoiconic C is simply conventions for creating and
evaluating Frames.

In this paper we will describe the complete syntax of HC, including three
types of lists, seven atoms, and the seven predefined operators; as a
modeless data format, there are no keywords, reserved words, or even any
grammar. Next we discuss the robust data protection semantics inspired by
BitC[@Shapiro:EffectTyping], which allow us the efficiency of C's memory
model without any of the downsides. Finally, we provide examples of how
these deceptively simple primitives allow us to trivially implement HTML,
Object-Oriented programming, and other higher-level abstractions.

We are currently developing the first implementation of HC as a
TypeScript[@TypeScript] interpreter. It can be found at
<http://github.com/TheSwanFactory/hclang/> under an MIT Open Source
license.

~
[^lua-fn]: The only minimalist language still in active use appears to be
    Lua[@Lua], though even that is relegated to niche applications.

[^monad]: Not just the mathematical term for an object closed under all
    operations, but Liebniz's original idea of a single universal
    building-block[@Liebniz].


# Introduction     { #sec-intro }

Homoiconic C is a data format for computation. It is designed to be a
simple yet powerful alternative to both traditional programming languages
and existing data formats.

## A Brief History of Programming Languages

Early high-level languages (e.g., FORTRAN[@Cite], COBOL[@Cite],
BASIC[@Cite], ALGOL[@Cite]) were strongly influenced by mathematics and artificial
intelligence[@Cite], leading to sophisticated precedence rules and
complicated syntax. The primary alternative was Lisp[@Lisp;], defined --
at least in theory -- by a single data structure (the list) and a single
rule (metacircular evaluation).

Lisp was not as efficient as, say, Fortran, but it was much more elegant
and powerful. The common assumption was that eventually computers would
become powerful enough that Lisp's inefficiencies would no longer matter.
Sadly, the failure of hardware-optimized Lisp machines[@Cite] marked the death
of that dream.

## Then Came C

Into that void stepped the C programming language[@CLang]. C was derived from ALGOL,
but borrowed (some would say butchered[@Cite]) several powerful ideas
from Lisp, such as macros[@Cite] and function pointers[@Cite]. In
addition, the C memory model[@Cite] mapped well onto modern processor
architectures, enabling remarkably good performance. It also benefited from:

* A relatively simple and easy to read syntax
* Association with the UNIX operating system
* Self-sustaining[@Cite], open source compilers

This led to C (along with its direct descendants, C++[@Cite] and
Objective-C[@Cite]) completely dominating the field for systems
programming; a situation which continues today, almost fifty years
later. This led to the C syntax (with some borrowing from its sister language, the UNIX shell)
becoming the baseline for virtually every mass-market language in use today[@Cite].

## The Downside of C

This success was not entirely a good thing. C's memory model and type
system optimized for efficiency at the cost of safety, leading to
innumerable programming errors and security holes that still plague us
today [@Cite]. C's syntax and macros --  a breath of fresh air
when they first came out -- feel clunky and dated in a world of scripting
languages and functional programming, to the point where it is rarely
taught to beginning programmers anymore.

In the last decade, we have seen renewed innovation in systems
programming, leading to languages such as Rust[@Cite], Go[@Cite], and
Swift [@Cite]. These are enough better and different than C that they
have carved out their own niches (especially with the help of powerful
patrons). However, they don't seem to have the factor-of-ten improvement
necessary to displace or replace C, the way C did to assembly language.

## Framing A New Hope { #sec-frames }

Homoiconic C aspires to reach that goal by marrying the best aspects of
C's syntax and memory model with the values of rigor and simplicity that
characterized Lisp. The central innovation is a novel data structure we
call a **frame**. Frames are simultaneously:

* Callable (like functions)
* Enumerable (like arrays)
* Associative (like structs)
* Inherited (like classes)

Our premise is that the multitude of structures found in programming
languages boil down to just these four attributes. By encoding
them in a single object, we hope to dramatically simplify both the structure
of the language and the process of programming.

HC also incorporates:

* Homoiconicity, from Lisp
  : Frames are both code and data, making it trivial to manipulate code via higher-level abstractions.
* Dataflow, from the UNIX Shell
  : Iteration and Input/Output are designed for simple pipeline-style composition.
* Effect Typing, from BitC[@Cite]
  : By carefully annotating function boundaries for both _constancy_ and _immutability_, we can safely
    alias data structures to get C-like performance while preserving the security of managed code.
* Lexical Scoping, from Scheme[@Cite]
  : Everything inherits its current scope (like closures). In addition, evaluation of closures causes the result to inherit their scope, allowing them to be used as object factories.


## About This Document

In the remainder of this document, we will cover:

* The syntax, operators, and data protection rules that define the language
* Examples of using Homoiconic C to model object-oriented programming and HTML
* The current status and possible future directions
* Conclusions and comparisons to related work



# Language Definition


## Syntax

The core principle of Homoiconic C syntax is _isomorphism_: every
syntactic construct refers to exactly one semantic concept. Put another
way, it is modeless: characters don't mean different things in different
places. This enables vastly simpler parsers and a much shallower learning
curve.

Like traditional data formats, HC is build around _literals_ and the
_terminals_ that separate and organize them. HC simply extends that with
_identifiers_, and a single grammatic construct, the _expression_. HC
documents that only use literals and terminals are called _data
programs_, or sometimes just _congrams_.

### Expressions

Expressions are simply zero or more frames evaluated within the current
context, then applied left to right (left fold [@LeftFold]). We refer to
this as the _elliptical evaluator_, in homage to Lisp's metacircular
evaluator.

```
  frame0 frame1 frame2 ...
```
Specifically:

1. _frame0_ is evaluated to _value0_ (also a frame)
2. _frame1_ is evaluated to _value1_
3. _value0_ is called with the argument _value1_, producing _result1_
4. -result1_ is called with _value2_ producing _result2_
5. The final _result_ is thus the value of the evaluated expression

The HC read-eval-print loop (REPL) uses ';' for the input prompt and '#' for the
output prompt:

``` ruby
; frame0
# value0
```

That's pretty much all there is. There are no special forms, keywords,
precedence rules, or other grammatic constructs. While we realize those
may provide some efficiency gains for experienced programmers, we do not
believe they are worth of cost of complicating the implementation and
increasing the learning curve for new programmers. And as we will show,
they are not at all necessary.

### Literals

Like any good data format, HC has a rich set of literals, described in
Table [#sec-table-literals].

~ TableFigure { #sec-table-literals; caption: "Literals Syntax" }

+----------|---------------+----------|---------------+--------------------+
| Integer                 || Non-Integer           || Quote              |
+----------|---------------+----------|---------------+--------------------+
| 0b010    | _binary_      |1/3| _rational_| “_string_”         |
| 0o1777   | _octal_       |123.456| _float_ | # _comment_ #      |
| 1234     | _decimal_     |123.456.E.-10| _scientific_ | \\_length_\\_blob_ |
| 0xCAFE   | _hexadecimal_ |123.456.p123| _version_ | %_date\_time_%     |
| 0@Base64 | _Base64_      |+1.408.555.1212| _phone_ |                    |
+----------|---------------+----------|---------------+--------------------+
{ tbody-tr-odd-background-color:Gainsboro; \
  tbody-tr-even-background-color:Floralwhite; }
~

The most significant departure from traditional syntax is the use of
matching smart quotes, which enables nesting and all but eliminates the
need for escape sequences. With appropriate editor support (an [atom
package](https://github.com/TheSwanFactory/language-maml) already exists),
the user can type '"' as usual and still generate HC strings.

In addition, as part of HC's quest to be a universal data format, it natively supports:

* Base64 numbers
* arbitrary-length binary and hexadecimal bitstreams
* net-string style blobs
* a dedicated time type and literal (to avoid overloading integers)

By definition, literals evaluate to themselves:
``` ruby
; “Hello, Homoiconicity!”
# “Hello, Homoiconicity!”
```
This is true even at the file level. A data program consistent entirely
of terminals and literals simply evaluates to (and prints out) itself, or
"[quines](https://en.wikipedia.org/wiki/Quine_%28computing%29)."

Because literals are also frames, they can be called ("All data is also
code"). Strings, for example, stringify and concatenate their argument.
``` ruby
; “Hello, ” “Homoiconicity!”
# “Hello, Homoiconicity!”
; “The Answer” “: ” 42
# “The Answer: 42”
```
Similarly, numbers replicate their argument that many times:
``` ruby
; 2 “Repeats”
# “RepeatsRepeats”
```

### Terminals

Terminals in Homoiconic C look much like those in ordinary languages, with a few
twists. See Table [#sec-table-terminals].

~ TableFigure { #sec-table-terminals; caption: "Terminals Syntax" }
+---------|-----------------------+------|-----------------+
| Separators                     || Aggregates            ||
+---------|-----------------------+------|-----------------+
| ,       | _end expression_      | (    | _begin group_   |
| ;       | _void expression_     | )    | _end group_     |
| newline | _end line_            | \[   | _begin array_   |
| space   | _split subexpression_ | ]    | _end array_     |
|                                || {    | _begin closure_ |
|                                || }    | _end closure_   |
+---------|-----------------------+------|-----------------+
{ tbody-tr-odd-background-color:Gainsboro; \
  tbody-tr-even-background-color:Floralwhite }
~

Formally speaking, each expression should terminate in an ',' or ';', depending
on whether we want to return the resulting value: ``` ruby ; “My Statement”; ;
“Self Expression”, # “Self Expression” ```  This effectively allows us to
distinguish "expressions" that return a value from "statements" that do not.
However, trailing commas are optional, if neither separator is present will be
inferred at the end of a line or aggregate.

Space plays an important role in binding, since we do not allow implicit
precedence. Spaces create a new subexpression, so frames that have no
space between them bind more tightly than those that do.

``` ruby
; “Want ” 2 “Live” # evaluates left to right
# “Want 2Live”
; “Want ” 2“Live” # evaluates `2“Live”` first
# “Want LiveLive”
```
This of course can also be done (with more visual clutter) by explicit grouping:
``` ruby
; “Want ” (2 “Live”) # evaluates left to right
# “Want LiveLive”
```

Arrays work as you'd expect:
``` ruby
; [1, 1, 2, 3, 5] 8
# [1, 1, 2, 3, 5, 8]
```

Closures are simply lazy expressions, which evaluate their contents when invoked.
``` ruby
; {42; “Life, ” “The Universe, ” “Everything.”} ()
# “Life, The Universe, Everything.”
```
The result of the empty expression (`()`) is called `nil`, and represents the Boolean false.
This will become important in Section [#sec-operators] when we discuss conditionals.

Note that statements inside a closure represent values that are not
returned, which becomes very powerful when we add identifiers.

### Identifiers

Everything else is just an identifier, which can be referred to as:

- `value`
- `.name`
- `@reference`


That completes our syntax[^mod].  Expressions are just literals and identifiers orgranized by terminals.

---
^[mod] Though identifiers may have suffixes and prefixes for access control,
as described in Section { #sec-table-access }.

#### Assignment

In particular, assignment is just a simple expression applying a _value_ to a _name_:
```
; .key value;
```
This avoids the subtle and confusing distinction between differing
"left-hand-side" and "right-hand-side" interpretations of an identical symbol _x_.
It also save us from overloading '=' to mean both assignment and a test for equality.

Names (setters) begin with a '.', and set a property with that label.
``` ruby
; .p 42;
```

Labels by themselves return that value.
``` ruby
; p
# 42
```


#### Properties

Names also provide an elegant way of manipulating data structures, still in the context of simple expressions:

```
  structure .property; # gets a property
  .structure.property value # sets a property
```
The space between _structure_ and _property_ is not necessary, but we include it to emphasize the fact
that this is just an ordinary expression, not a special syntax.

Note that due to the scoping rules, the value _structure_ can be either
local or in any parent scope, but the name _.structure_ is always local.  If we wish to
re-assign that parent value, we use an _@reference_:
```
  @structure.property value # sets a property in structure's current scope
```


When we group names, we get a dictionary:
``` ruby
; (.x 1, .y 2)
# (.x 1, .y 2)
```

We can also uses names as metadata insides an array of values:
``` ruby
; [.name "weights"; 85, 110, 165]
# [.name "weights"; 85, 110, 165]
```

We can refer to them from inside the same frame:
``` ruby
; .numbers [.min 3; .max 9; min, max]
# [.min 3; .max 9; min, max]
```

We can use them to extract data from outside the frame:
``` ruby
; numbers .min
# 3
```
The space before `.min` is optional, but emphasizes that property access is just another expression.

####  Anonymous Identifiers

Use `_` as the anonymous argument, representing everything this frame
was called with:
``` ruby
; .square {_ * _};
; square 3
# 9
```
This is useful not just for closures, but for representing the command-line
arguments for the entire script.

When you apply something to a closure, it is effectively inserting that
argument into the inheritance hierarchy.  Thus we can access properties
of the argument directly, rather than explicitly calling `_`.
``` ruby
; .mag {(x * x) + (y * y )};
; mag (.x 1; .y 2;)
# 5
```

You can skip over the argument to access the enclosing scope (one level above)
using the `^_` identifier (also known as `super`).
``` ruby
; .print-arg { var };
; .print-parent { ^_.var };
; .var “parent”;

; print-arg(.var “arg”)
# “arg”
; print-parent(.var “arg”)
# “parent”
```

Since objects capture the scope where they are created, this even allows closures to be called with implicit arguments to access the enclosing scope:
``` ruby
; .x 3;
; .y 4;
; mag []
# 25
```

Implicit argments are a code smell, and will generate a warning.
However, they can be very useful when debugging or refactoring. That may seem
dangerous, but the data protection rules (below) largely limit what the called
function can do to the calling scope.

#### Varieties

Identifiers can contain letters, numbers, or non-terminal symbols.
They come in several varieties as described in Table { #sec-table-id }.

~ TableFigure { #sec-table-id; caption: "Identifiers" }
+-----------+------------+---------------+--------------+
|Variety | Example  | Starts With       | Contains   |
+-----------+------------+---------------+--------------+
| Label  | _variable_ | _letter_      | _letter_, _number_, `-`  |
| Operator  | `+` | _symbol_ | _symbol_ |
| Control  | `$<-` # return | `$`     | _any identifier_  |
| Anonymous  | \_^ | \_ | \_,\^  |
+-----------+------------+---------------+--------------+
{ tbody-tr-odd-background-color:Gainsboro; \
  tr-even-background-color:Floralwhite }

~

Syntactically they are equivalent, with one small piece of syntactic sugar of operators.  Those default to being evaluated inside the preceding frame rather than the current context, so that values are treated as names (unless at the beginning of an expression).

``` ruby
; 2 .+ 2
# 4

; 2 + 2
# 4
```


## Operators

Homoiconic C pre-defines a small number of operators to provide functionality
other languages often hard-code into their syntax:

~ TableFigure { #sec-table-op; caption: "Pre-Defined Operators" }
+-----------+------------+---------------+--------------+
| Content                                        ||||
|Role | Data  | Metadata       | Both   |
+-----------+------------+---------------+--------------+
| Equality   | = | ==      | ===  |
| Map  | \| | \|\| | \|\|\|  |
| Fold          |     &      |  && | &&& |
+-----------+------------+---------------+--------------+
{ tbody-tr-odd-background-color:Gainsboro; \
  tr-even-background-color:Floralwhite }

+-------|--------+---|--------------+--------|--------+
| Structure                              |||||        |
| Conditional   || Type            || Bind   |        |
+-------|--------+---|--------------+--------|--------+
| ?     | _if_   | < | _begin type_ | ^    | _bind type_|
| :     | _else_ | > | _end type_   | ~ |_has type_|
+-------|--------+---|--------------+--------|--------+
{ tbody-tr-odd-background-color:Gainsboro; \
  tr-even-background-color:Floralwhite }
~

#### Type Operations
In HC, type is declared using a pair of operators, not a syntactic construct. This works because types are just expressions, and thus do not need to change
the evaluation rules.

Like all modern statically typed languages, HC relies heavily on type
inference. By using dataflow, we also eliminate the need to define variables
for loops or temporary variables.  In addition, the fact that every frame is
callable means we can often simply treat arguments as generic frames.

However, there are times we do need to explicitly annotate what kind of frames
we are expecting, in which case we use the type operators:
``` ruby
```

The opposite of the nil expression is the _all_ type, or universal set:
``` ruby
; <>
# <>
; !()
; <>
```

`All` is also used as the boolean `true`.
``` ruby
; 1 = 5
# <>
```
Remember that `=` is only use for comparison, never for assignment, so we
don't need to use `=` for simple value comparison.

`All` has the property that every object is a member (`~`), in contrast to nil of which nothing is a member:
``` ruby
; 1 ~ <>
# <>
; 2 ~ ()
; ()
```
### Conditionals

The ternary operator can be broken into two binary operators (with slightly different semantics).

In Homoiconic C, these are not special forms, but simply pre-defined on the root object,
and overridden by nil (or more precisely, vice-versa).

Most objects evaluate the argument of `?` and return nil for `:`,
but nil itself does the reverse.

``` ruby

; 1 ? {2 + 2}
# 4
; 1 : {2 + 2}
# ()

; () ? {2 + 2}
# ()
; () : {2 + 2}
# 4
```

Which, when the first expression does not return nil, acts like the ternary
operator:
``` ruby
; ( 1 > 5 ) ? 100 : 10
# 10
```

Note that applying nil to anything other than a closure has no effect.

### Iterators

We use `|` for map, in homage to the UNIX pipeline.
``` ruby
; [1, 2, 3] | { _ + 1 }
# [2, 3, 4]
```

Similarly, we use `&` for reduce:
``` ruby
; [1, 2, 3] & { . + _ }
# 6
```

###  Data and Metadata



## Access Control { #sec-table-access }

~ TableFigure { #sec-table-id; caption: "Identifiers" }
+-----------+------------+---------------+--------------+
| Identifiers                                        ||||
|Assignment | Constancy  | Privacy       | Effect   |
+-----------+------------+---------------+--------------+
| _value_   | _variable_ | _public_      | _immutable_  |
| ._name_   | _Constant_ | \__protected_ | _mutable_\_  |
|           |            | \_\__private_ | _mutating_: |
+-----------+------------+---------------+--------------+
{ tbody-tr-odd-background-color:Gainsboro; \
  tr-even-background-color:Floralwhite }

### Effect Typing

Rather than specify call-by-value or call-by-reference, HC is designed around the BitC model for effect typing.  Shapiro *et al* proved it is possible to have a [sound *and* complete](www.cs.jhu.edu/~swaroop/aplas.pdf) systems language if you explicitly annotate variables for **constancy** and **mutability** at each context boundary. This gives the compiler enough information to know how and when to safely copy or share data structures.

 Unfortunately, they could not do that within their Lisp-like syntax. Inspired by their work, we have chosen to use the bulk of our "syntax budget" to address that problem.  In particular, we believe effect is so fundamental we bake it into our identifiers:

 - `CONST` # begins with uppercase letter
 - `variable` # does not
 - `mutable_` # trailing underscore
 - `immutable` # default
 - `mutating_method:` # trailing colon

Their core insight is that mutability is a property of the *handle*, not the *object*.  Every object starts out mutable, but as long as it is only referenced from immutable handles the compiler can share a single instance between them.  Even if a context specifies a mutable handle, that only maters if it is called by a mutating method, which becomes copy-on-write.  For that reason, all mutating methods are required to return 'self'.

This approach may seem incomplete, in that it doesn't specify the mutability of object literals.  But if accessed directly without a handle, there is no way of knowing (or caring) whether the literal was mutated or not!

Please note that these particular conventions are preliminary, and may change in future versions based on empirical tests of readability and intuitiveness.  Since HC is just a data format, it is trivial to semantically version, and define conversions from obsolete versions.


## Access Modifiers

Closely related to effect typing (which determines *what* can change) are access modifiers (which determine *who* can change or see that). To streamline the grammar and readability, we also bake those into the identifiers, following the typical C conventions:

- `public` # default
- `_protected` # not accessible from parent
- `__private` # not accessible by children



# Applications

## Object-Orientation

Perhaps surprisingly, it is possible to implement a complete object-oriented
programming system using only the above primitives.


### Constructors

Let's start with a simple singleton:

``` ruby
; .parent_ [
# # .x 1;
# # .helper: {
#   # .x 2;
#   # .y x + _^.x;
#   # ._^.y y + _;
#   # }
# # ]
; parent_.x
# 1
; parent.y
# $missing
; parent_.helper: 10;
; parent_.y
# 13
```

Then move on to classes:
```
; my-class {
  ._property _;
  .getProperty { _^._property }
  .setProperty: { ._^._property _}
};
; .my-instance my-class 3;
; my-instance.getProperty()
# 3
; .mutated = my-instance.setProperty: 42;
; mutated.getProperty()
# 42
; my-instance.getProperty()
# 3
```

This may seem to good to be true, but that is the power of choosing the correct primitives:

- Data hiding is handled by the implicit access Modifiers
- Scope is always inherited
- Instance methods refer to their parent by `_^`
- The class itself is the constructor (as a closure)
- When evaluated, that closure inherits the class as its parent

### Extending Classes

Even inheritance is already accounted for, simply by allowing an object to specify its parent:

``` ruby
; my-subclass {
  ._^ my-base-class
};
```

There is no built-in support for multiple inheritance.  However, because
inheritance is just another expression, you are welcome to define your own:

``` ruby
; .my-multiple-inheritance { “create your own” };
; multiclass {
  ._^ my-multiple-inheritance[my-base, another-base]
};
```

## HTML

# Next Steps

## Implementation Status

## Future Directions

## Potential Implications



# Related Work

* BitC [sound *and* complete](www.cs.jhu.edu/~swaroop/aplas.pdf)
* Water http://www.informit.com/articles/article.aspx?p=27567
* Mathematica https://mathematica.stackexchange.com/questions/2335/metaprogramming-in-mathematica
* Julia https://julialang.org

# Conclusion

We believe the historical accident of confusing computation with mathematics
and programming with natural languages has resulted in massive accidental
complexity, resulting in buggy software, complicated tools, and steep learning.
By eliminated that complexity, Homoiconic C promises to usher in a new Golden Age of software that is:

* Provably secure by default
* Both inherently efficient and easily optimized
* Easy to learn, read, and modify
* Trivial to statically analyze, visualize, and automatically evolve

If Homoiconic C fulfills that promise, we can finally make programming an
everyday skill, used by ordinary people (even children) to solve the problems
*they* care about, in the same way they use writing and arithmetic.  Not
everyone will be an expert or professional programmer -- anymore than everyone who sings is an expert or professional musician -- but the ability to
read, understand, and personalize code will be available to all.

It may be true that there is no silver bullet[@Cite].   But we believe
Homoiconic C can at least be a "diamond sword", enabling courageous individuals
to bring safety, performance, usability, and clarity to the software that
impacts their corner of the world.  We hope you will join us on that quest.


# Appendices

## Appendix A. On Turing Completeness

Turing undecidability, like Godelian incompleteness, starts by assuming "basic arithmetic" (add, substract, multiply, divide) -- i.e. the Peano Axioms. However, this glosses over the fact that division is a "type violation", and can't be fully represented using the same data structures as for addition and substraction.

We believe that a better starting point for modeling computation are the Presburger Axioms.  These give up multiplication and division as first-class operations (though you can emulate them to some extent using repeated addition and subtraction, respectively).  The big win, though, is that Presburger arithmetic is both consistent **and** complete.  This eliminates the halting problem, and massively simplifies analyses (though it may restrict what is possible).

Instead of Turing completeness, we prefer to focus on "Circuit Universality" (a la Scott Aaronson): the ability to represent the effect of any Boolean circuit, including multiple levels of abstraction above them.

[BIB]
