
Title         : Homoiconic C
Subtitle      : Programming without a Language

HideAuthor        : Ernest N. Prabhakar
HideAffiliation   : The Swan Factory, Inc.
HideEmail         : ernest.prabhakar@gmail.com

Bib style     : plainnat
Bibliography  : hc-refs.bib
Logo          : True
Package       : amsmath
Doc class     : [preprint]{sigplanconf}

[TITLE]

~ Abstract
  
Modern programming is dominated by languages derived from C[@CLang] and
the UNIX shell[@UNIXShell], characterized by complicated syntax and
sophisticated parsers. Minimalist languages such as Forth[@Forth],
Scheme[@Scheme] and Self[@Self] are no longer taken seriously[^lua-fn],
presumably because they are felt to lack sufficiently readable _syntax_
and powerful enough _semantics_.

In this paper we introduce a novel data format called **Homoiconic C**
("HC") that we claim expresses a safe superset of C-like computations,
yet is even easier to read than existing scripting languages. The key is
a novel data structure and computational model we call _Frames_, designed
to replace and improve upon the s-expressions and metacircular evaluation
model of Lisp[@Lisp]. Frames act as a universal monad[^monad], with the
result that Homoiconic C is simply conventions for creating and
evaluating Frames.

In this paper we will describe the complete syntax of HC, including three
types of lists, seven atoms, and the seven predefined operators; as a
modeless data format, there are no keywords, reserved words, or even any
grammar. Next we discuss the robust data protection semantics inspired by
BitC[@Shapiro:EffectTyping], which allow us the efficiency of C's memory
model without any of the downsides. Finally, we provide examples of how
these deceptively simple primitives allow us to trivially implement HTML,
Object-Oriented programming, and other higher-level abstractions.

We are currently developing the first implementation of HC as a
TypeScript[@TypeScript] interpreter. It can be found at
<http://github.com/TheSwanFactory/hclang/> under an MIT Open Source
license.

~
[^lua-fn]: The only minimalist language still in active use appears to be
    Lua[@Lua], though even that is relegated to niche applications.
    
[^monad]: Not just the mathematical term for an object closed under all
    operations, but Liebniz's original idea of a single universal
    building-block[@Liebniz].

# Introduction     { #sec-intro }

Blah.

# Frames   { #sec-frames }

HC is fully homoiconic. Not only is code **a** data structure, all code
_and_ data is represented by a single structure we call a **frame**. This is possible because all
frames are simultaneously:

* Callable (like functions)
* Enumerable (like arrays)
* Associative (like dictionaries)
* Scopes (like modules)

Our hypothesis is that the multitude of structures found in programming
languages boil down to just these four attributes. While frames may seem
complex, they make everything else much simpler.

# Syntax

The core principle of Homoiconic C syntax is _isomorphism_: every
syntactic construct refers to exactly one semantic concept. Put another
way, it is modeless: characters don't mean different things in different
places. This enables vastly simpler parsers and a much shallower learning
curve.

Like traditional data formats, HC is build around _literals_ and
the _terminals_ that separate and organize them. HC simply extends that
with _identifiers_, and a single grammatic construct, the _expression_.

## Data Format 

Homoiconic C is intended to be a universal format for data as well as code.
The pure data constructs are found in Table [#sec-table-data].

~ TableFigure { #sec-table-data; caption: "Data Format Specification" }

+----|---------------+----------|---------------+--------------------+
| Literals                                                       |||||
| Bit               || Number                  || Quote              |
+----|---------------+----------|---------------+--------------------+
| <> | _all (true)_  | 0b010    | _binary_      | “_string_”         |
| () | _nil (false)_ | 0o1777   | _octal_       | # _comment_ #     |
|                   || 1234     | _decimal_     | \\_length_\\_blob_ |
|                   || 0xCAFE   | _hexadecimal_ | %_date\_time_%     |
|                   || 0@Base64 | _Base64_      |                    |
+----|---------------+----------|---------------+--------------------+
{ tbody-tr-odd-background-color:Gainsboro; \
  tr-even-background-color:Floralwhite; cell-padding 10ex; }

+-----------|------------------+------|-----------------+---------|-------------------+
| Terminals                                                                      ||||||
| Separators                  || Aggregates            || Whitespace                 ||
+-----------|------------------+------|-----------------+---------|-------------------+
| ,         | _end expression_ | (    | _begin group_   | space   | _separate tokens_ |
| ;         | _end statement_  | )    | _end group_     | newline | _end group_       |
|                             || ]    | _end array_     |                            ||
|                             || \[   | _begin closure_ |                            ||
|                             || ]    | _end closure_   |                            ||
+-----------|------------------+------|-----------------+---------|-------------------+
{ tbody-tr-odd-background-color:Gainsboro; \
  tr-even-background-color:Floralwhite }
~

To be precise, '<>' is the total type and '()' is the empty expression, but since they evaluate to
themselves they can be considered literals.

## Identifiers 

~ TableFigure { #sec-table-id; caption: "Identifiers" }
+-----------+------------+---------------+--------------+
| Identifiers                                        ||||
|Assignment | Constancy  | Privacy       | Effect   |
+-----------+------------+---------------+--------------+
| _value_   | _variable_ | _public_      | _immutable_  |
| ._name_   | _Constant_ | \__protected_ | _mutable_\_  |
|           |            | \_\__private_ | _mutating_: |
+-----------+------------+---------------+--------------+
{ tbody-tr-odd-background-color:Gainsboro; \
  tr-even-background-color:Floralwhite }

+---------------+
|Special        |
+-----+
| \@_reference_ |
| $_control_    |
+---------------+
{ tbody-tr-odd-background-color:Gainsboro; \
  tr-even-background-color:Floralwhite }
~

## Operators 

~ TableFigure { #sec-table-op; caption: "Pre-Defined Operators" }
+-----------+------------+---------------+--------------+
| Content                                        ||||
|Role | Data  | Metadata       | Both   |
+-----------+------------+---------------+--------------+
| Equality   | = | ==      | ===  |
| Map  | \| | \|\| | \|\|\|  |
| Fold          |     &      |  && | &&& |
+-----------+------------+---------------+--------------+
{ tbody-tr-odd-background-color:Gainsboro; \
  tr-even-background-color:Floralwhite }

+-------|--------+---|--------------+--------|--------+
| Structure                              |||||        |
| Conditional   || Type            || Bind   |        |
+-------|--------+---|--------------+--------|--------+
| ?     | _if_   | < | _begin type_ | “_string_”     ||
| :     | _else_ | > | _end type_   | # _comment_ #  ||
+-------|--------+---|--------------+--------|--------+
{ tbody-tr-odd-background-color:Gainsboro; \
  tr-even-background-color:Floralwhite }
~

Note the type is just a pair of operators, not a syntactic construct,
since it does not change the evaluation rules.



## Expressions 

Expressions are simply a list of frames evaluated within the current context then applied left to
right (left fold [@LeftFold]).

```
  frame0 frame1 frame2 ...
```
This is equivalent to the explicit grouping:
```
  ((frame0 frame1) frame2)
```

The only variation on this is 




## Operators

# Data Protection

## Encapsulation

## Effect Typing

# Applications

## Object-Orientation

Let's program some Javascript:
``` javascript
function hello() {
  return "hello world!"
}
```

## Web Technologies

# Next Steps

## Implementation Status

## Future Directions

## Potential Implications

# Related Work

~ Note
The syntax highlighting works in the PDF output too.
~

# Conclusion

Really fun to write Markdown :-)

[BIB]
