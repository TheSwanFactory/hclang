# Deno Hooks: A Native Git Hooks Framework for Deno

**Version**: 0.1.0
**Status**: Specification Draft
**Date**: 2025-12-14

## Abstract

Deno Hooks is a zero-dependency git hooks framework written in pure TypeScript for Deno. It provides a declarative configuration system for git hooks that runs entirely within the Deno runtime, eliminating the need for external tools like Python's pre-commit or Node.js-based alternatives.

## Motivation

### The Problem

Modern development workflows rely on git hooks for code quality enforcement, but existing solutions have significant drawbacks:

- **pre-commit** (Python): Requires Python installation, conda/pip dependencies, and is slow to start
- **Husky** (Node.js): Requires npm/node_modules, designed for Node.js ecosystem
- **Lefthook** (Go): Requires external binary installation, platform-specific builds

For Deno projects, these tools introduce unnecessary runtime dependencies and friction for new contributors.

### The Solution

Deno Hooks leverages Deno's strengths:

1. **Zero External Dependencies**: Pure TypeScript, runs on Deno runtime
2. **Cross-Platform**: Single codebase works on macOS, Linux, Windows
3. **Fast**: Deno's JIT compilation and built-in caching
4. **Type-Safe**: Full TypeScript support with compile-time checks
5. **Secure**: Deno's permission system prevents unauthorized operations
6. **Built-in Tools**: Uses Deno's built-in formatter, linter, test runner

## Goals

### Primary Goals

1. **Easy Installation**: Single command setup with no external dependencies
2. **Declarative Configuration**: YAML or JSON config file for hook definitions
3. **Built-in Hooks**: Common checks work out-of-the-box (fmt, lint, test, etc.)
4. **Custom Hooks**: Support user-defined hooks in TypeScript/JavaScript
5. **Performance**: Parallel execution, staged file filtering, incremental checks
6. **Compatibility**: Works with standard git hook lifecycle

### Non-Goals

1. **Universal Language Support**: Focus on Deno/TypeScript ecosystem (no Ruby, Go, Rust hooks)
2. **Complex Dependency Resolution**: No hook dependency management (keep it simple)
3. **Remote Hook Repositories**: No downloading hooks from external sources (security)

## Architecture

### High-Level Design

```
┌─────────────────────────────────────────────────────────┐
│ Git Hook Trigger (.git/hooks/pre-commit)               │
│ ├─ Shell script wrapper                                 │
│ └─ Calls: deno run -A deno-hooks/run.ts <hook-name>    │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ Deno Hooks Runner (deno-hooks/run.ts)                  │
│ ├─ Load configuration (deno-hooks.yml)                 │
│ ├─ Resolve hook definitions                            │
│ ├─ Execute hooks (parallel where possible)             │
│ └─ Aggregate results and exit with status              │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ Hook Implementations (deno-hooks/hooks/*.ts)           │
│ ├─ Built-in: fmt, lint, test, check-yaml, etc.        │
│ └─ Custom: User-defined TypeScript modules             │
└─────────────────────────────────────────────────────────┘
```

### Component Breakdown

#### 1. Installation (`install.ts`)

```typescript
// deno-hooks/install.ts
export async function install(): Promise<void>
```

**Responsibilities:**
- Create `.git/hooks/` directory if missing
- Generate shell wrapper scripts for each configured hook
- Make scripts executable (Unix) or configure via git (Windows)
- Validate configuration file exists
- Report installation status

**Generated Hook Script Example:**
```bash
#!/bin/sh
# Generated by deno-hooks - DO NOT EDIT
exec deno run -A "$(git rev-parse --show-toplevel)/deno-hooks/run.ts" "pre-commit" "$@"
```

#### 2. Hook Runner (`run.ts`)

```typescript
// deno-hooks/run.ts
export async function run(hookName: string): Promise<number>
```

**Responsibilities:**
- Parse command-line arguments (hook name, git-provided args)
- Load and validate configuration
- Determine which hooks to run for the given trigger
- Get staged files (for pre-commit) or affected files
- Execute hooks in parallel where possible
- Collect and display results
- Return appropriate exit code

**Execution Flow:**
1. Parse hook name (e.g., "pre-commit")
2. Load `deno-hooks.yml` or `deno.json` config
3. Get relevant files (staged, modified, or all)
4. For each configured hook:
   - Resolve hook implementation (built-in or custom)
   - Check if file patterns match
   - Execute hook with matched files
5. Collect results (success/failure/skipped)
6. Display summary
7. Exit with 0 (success) or 1 (failure)

#### 3. Configuration (`config.ts`)

```typescript
// deno-hooks/config.ts
export interface Config {
  hooks: {
    [hookName: string]: Hook[];
  };
}

export interface Hook {
  id: string;           // Unique identifier (e.g., "deno-fmt")
  name?: string;        // Display name (defaults to id)
  run: string;          // Command or built-in hook name
  glob?: string;        // File pattern to match (e.g., "*.ts")
  pass_filenames?: boolean; // Pass matched files as arguments
  exclude?: string;     // Glob pattern to exclude
  parallel?: boolean;   // Allow parallel execution with other hooks
}
```

**Configuration File Format (deno-hooks.yml):**
```yaml
hooks:
  pre-commit:
    - id: deno-fmt
      glob: "*.{ts,js,json,md}"
      pass_filenames: true

    - id: deno-lint
      glob: "*.{ts,js}"
      pass_filenames: true

    - id: check-yaml
      glob: "*.{yml,yaml}"
      run: "./deno-hooks/hooks/check-yaml.ts"

    - id: no-merge-conflicts
      run: "./deno-hooks/hooks/check-merge-conflict.ts"
      pass_filenames: true

  pre-push:
    - id: test
      run: "deno test -A"
      pass_filenames: false
```

**Alternative: deno.json Integration:**
```json
{
  "deno-hooks": {
    "hooks": {
      "pre-commit": [
        {
          "id": "deno-fmt",
          "glob": "*.{ts,js,json,md}",
          "pass_filenames": true
        }
      ]
    }
  }
}
```

#### 4. Built-in Hooks (`hooks/`)

**Required Built-ins:**

- `fmt.ts` - Run `deno fmt` on staged files
- `lint.ts` - Run `deno lint --fix` on staged files
- `test.ts` - Run `deno test` (configurable paths)
- `check-yaml.ts` - Validate YAML syntax
- `check-json.ts` - Validate JSON syntax
- `trailing-whitespace.ts` - Check for trailing whitespace
- `end-of-file-fixer.ts` - Ensure files end with newline
- `check-merge-conflict.ts` - Detect merge conflict markers
- `check-large-files.ts` - Prevent committing large files

**Hook Interface:**
```typescript
// deno-hooks/hook.ts
export interface HookContext {
  files: string[];      // Matched files to process
  hookName: string;     // Current hook trigger (e.g., "pre-commit")
  config: Hook;         // Hook configuration
  rootDir: string;      // Git repository root
}

export interface HookResult {
  success: boolean;
  message?: string;
  files?: string[];     // Files that were modified (for auto-fixing)
}

export type HookFunction = (ctx: HookContext) => Promise<HookResult>;
```

**Example Built-in Hook:**
```typescript
// deno-hooks/hooks/fmt.ts
import { HookContext, HookResult } from "../hook.ts";

export default async function fmt(ctx: HookContext): Promise<HookResult> {
  if (ctx.files.length === 0) {
    return { success: true, message: "No files to format" };
  }

  const command = new Deno.Command("deno", {
    args: ["fmt", ...ctx.files],
    cwd: ctx.rootDir,
  });

  const { success, stdout, stderr } = await command.output();

  if (!success) {
    const error = new TextDecoder().decode(stderr);
    return { success: false, message: error };
  }

  const output = new TextDecoder().decode(stdout);
  const modified = output.includes("Checked") && !output.includes("0 files");

  return {
    success: true,
    message: modified ? "Formatted files" : "All files formatted",
    files: modified ? ctx.files : [],
  };
}
```

#### 5. File Utilities (`files.ts`)

```typescript
// deno-hooks/files.ts

/** Get staged files for pre-commit hook */
export async function getStagedFiles(): Promise<string[]>

/** Get modified files (staged + unstaged) */
export async function getModifiedFiles(): Promise<string[]>

/** Filter files by glob pattern */
export function filterFiles(files: string[], pattern: string): string[]

/** Check if file matches any exclude pattern */
export function isExcluded(file: string, patterns: string[]): boolean

/** Get all tracked files in repository */
export async function getAllFiles(): Promise<string[]>
```

**Implementation Notes:**
- Use `git diff --cached --name-only --diff-filter=ACM` for staged files
- Use `git diff --name-only --diff-filter=ACM` for unstaged files
- Use `git ls-files` for all tracked files
- Implement glob matching using `std/path/glob.ts` or similar

## User Experience

### Installation Flow

```bash
# 1. Add deno-hooks to workspace
cd my-project/
mkdir deno-hooks/
# Copy deno-hooks files or add as git submodule

# 2. Create configuration
cat > deno-hooks.yml << EOF
hooks:
  pre-commit:
    - id: deno-fmt
      glob: "*.{ts,js,json,md}"
      pass_filenames: true
    - id: deno-lint
      glob: "*.{ts,js}"
      pass_filenames: true
  pre-push:
    - id: test
      run: "deno test -A"
EOF

# 3. Install hooks
deno run -A deno-hooks/install.ts

# 4. Verify installation
git commit -m "test" # Should trigger hooks
```

### Typical Commit Flow

```bash
$ git add file.ts

$ git commit -m "Add feature"

Running pre-commit hooks...
  ✓ deno-fmt (2 files formatted)
  ✓ deno-lint (no issues)
  ✓ check-yaml (1 file checked)
  ✓ no-merge-conflicts (1 file checked)

All hooks passed! ✨

[main abc123] Add feature
 1 file changed, 10 insertions(+)
```

### Failed Hook Flow

```bash
$ git commit -m "Add feature"

Running pre-commit hooks...
  ✓ deno-fmt (no changes)
  ✗ deno-lint (3 issues found)

    error: 'foo' is never used
      at file:///path/to/file.ts:10:7

    error: Missing return type on exported function
      at file:///path/to/file.ts:15:1

Hooks failed! ❌

Fix the issues above and try again.
```

## Implementation Phases

### Phase 1: Minimal Viable Product (MVP)

**Goal**: Replace pre-commit for HC project

**Deliverables:**
1. ✅ Basic project structure
2. ✅ Configuration parser (YAML support)
3. ✅ Installation script
4. ✅ Hook runner with sequential execution
5. ✅ 3 built-in hooks: fmt, lint, test
6. ✅ Staged file detection
7. ✅ Glob pattern matching
8. ✅ Basic error reporting

**Timeline**: 1-2 days
**Success Criteria**: HC project uses deno-hooks instead of pre-commit

### Phase 2: Feature Completeness

**Goal**: Production-ready with common use cases

**Deliverables:**
1. ⬜ Parallel hook execution
2. ⬜ All built-in hooks (8 total)
3. ⬜ Custom hook support
4. ⬜ File exclude patterns
5. ⬜ Hook dependencies
6. ⬜ Auto-fixing with re-staging
7. ⬜ Better error messages
8. ⬜ Skip hooks via env var (SKIP_HOOKS)
9. ⬜ Dry-run mode

**Timeline**: 3-5 days
**Success Criteria**: Ready for other Deno projects to adopt

### Phase 3: Polish & Distribution

**Goal**: Publish to JSR, documentation, community adoption

**Deliverables:**
1. ⬜ Comprehensive documentation
2. ⬜ Example configurations
3. ⬜ JSR package publication
4. ⬜ CI/CD integration guide
5. ⬜ Performance benchmarks
6. ⬜ Migration guide from pre-commit
7. ⬜ Logo and branding
8. ⬜ Community outreach

**Timeline**: 1 week
**Success Criteria**: 10+ projects using deno-hooks, positive feedback

## Technical Decisions

### Why YAML for Configuration?

**Pros:**
- Familiar to pre-commit users (easy migration)
- More readable for multi-line configurations
- Comments support
- Standard in DevOps tools

**Cons:**
- Requires parsing library (use `std/yaml`)
- Not native to Deno (JSON is native)

**Decision**: Support both YAML (`deno-hooks.yml`) and JSON (`deno.json` integration). YAML is primary, JSON is convenience.

### Why Shell Wrapper Scripts?

**Alternatives Considered:**
1. **Pure TypeScript hooks**: Wouldn't work with git (needs executable in `.git/hooks/`)
2. **Deno compile binaries**: Slow, large, platform-specific
3. **Git hook templates**: Requires git config, not portable

**Decision**: Shell wrappers are simple, portable, and standard practice. Windows uses git's shell emulation.

### Why Not Support Remote Hooks?

**Security Concerns:**
- Downloading and executing code from the internet is dangerous
- No verification mechanism (checksums, signatures)
- Supply chain attack vector

**Decision**: Local hooks only. Users can vendor dependencies in their repo if needed.

### Error Handling Philosophy

**Principle**: Fail fast, fail clearly

1. **Installation Errors**: Halt setup, provide clear instructions
2. **Configuration Errors**: Validate on install, fail early
3. **Hook Failures**: Stop commit, show actionable error messages
4. **Runtime Errors**: Catch and display, never leave repo in bad state

## Compatibility

### Git Versions

**Minimum**: Git 2.9+ (required for `core.hooksPath`)
**Recommended**: Git 2.20+ (better hook performance)

### Deno Versions

**Minimum**: Deno 1.40+ (required for `Deno.Command`)
**Recommended**: Deno 2.0+ (stable API, better performance)

### Operating Systems

- ✅ macOS (Intel & Apple Silicon)
- ✅ Linux (x86_64, aarch64)
- ✅ Windows (via Git Bash / WSL)

## Performance Considerations

### Optimization Strategies

1. **Lazy Loading**: Only load hook implementations when needed
2. **File Filtering**: Only process files matching glob patterns
3. **Parallel Execution**: Run independent hooks concurrently
4. **Incremental Checks**: Only check changed files (not entire codebase)
5. **Caching**: Use Deno's built-in module cache

### Performance Goals

- **Installation**: < 1 second
- **Hook Execution**: < 5 seconds for typical commit (10 files)
- **Startup Overhead**: < 100ms (Deno runtime + config parsing)

### Benchmarks (Target)

| Operation | Target | Notes |
|-----------|--------|-------|
| Install hooks | < 1s | One-time setup |
| Load config | < 50ms | Parse YAML/JSON |
| Get staged files | < 100ms | Git command |
| Run deno fmt | < 2s | 10 TypeScript files |
| Run deno lint | < 3s | 10 TypeScript files |
| Total (pre-commit) | < 5s | All hooks combined |

## Security Model

### Permission Requirements

Deno-hooks requires the following permissions:

```bash
deno run -A deno-hooks/run.ts  # Full permissions (easier)

# Or explicit permissions:
deno run \
  --allow-read \      # Read config, source files
  --allow-write \     # Auto-fix files
  --allow-run=git,deno \  # Run git and deno commands
  deno-hooks/run.ts
```

**Justification:**
- `--allow-read`: Must read config and source files
- `--allow-write`: Optional, only for auto-fixing hooks
- `--allow-run=git,deno`: Must invoke git and deno commands

### Threat Model

**Trusted:**
- Repository owner (controls configuration)
- Hook implementations in repo
- Git itself

**Untrusted:**
- Network (no remote hook execution)
- User input (file paths validated)

**Attack Vectors:**
- Malicious hook configuration (mitigated: local only, reviewed in PR)
- Path traversal (mitigated: validate file paths)
- Command injection (mitigated: use `Deno.Command`, not shell)

## Future Enhancements

### Post-MVP Features

1. **Hook Marketplace**: Curated list of community hooks (no auto-download)
2. **IDE Integration**: VS Code extension, pre-commit UI
3. **Commit Message Hooks**: Validate commit messages (commit-msg hook)
4. **Post-Commit Hooks**: Notifications, deployment triggers
5. **Monorepo Support**: Run hooks only in affected packages
6. **Performance Profiling**: Show which hooks are slow
7. **Hook Dependencies**: Run hooks in specific order
8. **Conditional Hooks**: Skip based on branch, file patterns
9. **Interactive Mode**: Prompt user for decisions (skip hook, fix manually)

### Research Areas

1. **Incremental Type Checking**: Use `deno check` with caching
2. **Distributed Hooks**: Run hooks in CI, cache results
3. **Fuzzy Matching**: Smart file detection (e.g., related test files)
4. **Language Server Integration**: Real-time hook feedback in editor

## Comparison to Alternatives

### vs Pre-commit

| Feature | Deno Hooks | Pre-commit |
|---------|------------|------------|
| Runtime | Deno | Python |
| Installation | `deno run install.ts` | `pip install pre-commit` |
| Config Format | YAML/JSON | YAML |
| Startup Time | ~100ms | ~500ms |
| Parallel Hooks | ✅ | ✅ |
| Remote Hooks | ❌ | ✅ |
| Language Support | Deno/TS | Universal |

**Migration Path**: Provide conversion tool to transform `.pre-commit-config.yaml` to `deno-hooks.yml`

### vs Husky

| Feature | Deno Hooks | Husky |
|---------|------------|-------|
| Runtime | Deno | Node.js |
| Config | YAML/JSON | package.json |
| Dependencies | 0 | npm install |
| Deno Projects | Native | Requires Node |

### vs Lefthook

| Feature | Deno Hooks | Lefthook |
|---------|------------|----------|
| Runtime | Deno | Go binary |
| Installation | Deno run | Binary download |
| Config | YAML/JSON | YAML |
| Extensibility | TypeScript | Shell scripts |
| Type Safety | ✅ | ❌ |

## Open Questions

1. **Should we support hook dependencies?** (e.g., "run fmt before lint")
   - **Lean**: No, keep it simple. User can order hooks in config.
   - **Consideration**: May revisit if users request it.

2. **How to handle auto-fixing and re-staging?**
   - **Proposal**: If hook modifies files, show warning and require manual re-add
   - **Alternative**: Auto `git add` fixed files (risky, could stage unwanted changes)

3. **Should we vendor the YAML parser or use JSR dependency?**
   - **Proposal**: Use `std/yaml` from JSR (trusted source, maintained)
   - **Alternative**: Vendor for stability (but creates maintenance burden)

4. **Windows support: Git Bash vs native cmd.exe?**
   - **Proposal**: Require Git Bash (standard with Git for Windows)
   - **Alternative**: Support both (complex, limited benefit)

## References

- [Git Hooks Documentation](https://git-scm.com/docs/githooks)
- [Pre-commit Framework](https://pre-commit.com/)
- [Deno Permissions](https://deno.land/manual/getting_started/permissions)
- [Lefthook](https://github.com/evilmartians/lefthook)
- [Husky](https://typicode.github.io/husky/)

## Changelog

- **2025-12-14**: Initial specification draft
