= nasm: The Nock Assembler

== Introduction

`nasm` is an high-level assembly language for nock bytecode.

It defines symbols, conventions, tools and libraries that make it easy
for Earthlings to read and write nock.

=== Example

```hclang
; .nock <- `nock`
; nock.assemble {[50, 51] (get 2)}
# [[50, 51], [0, 2]]
; nock.print .-1
# `[50 51] [0 2]`
; nock.eval .-2
# 50
```

=== Homoiconic C

`nasm` is written in Homoiconic C ("hclang"), another minimalist axiomatic language.
It uses:

- `[square brackets]` for comma-seperated lists ("boxed" grouping)
- `(round brackets)` for expressions ("unboxed" grouping)
- `{curly brackets}` for closures ("lazy" evaluation)
- `.name value` to assign (immutable) variables
- `;` to terminate expressions (and as the REPL input prompt)
- `#` for comments (and as the REPL output prompt)
- `<-` to load modules
- `backticks` ("`") for strings

=== Compiling to Assembly

While hclang is an impure systems language (inspired by BitC),
it includes a pure subset that can be compiled to Nock assembly:

```hclang
; [50, 51].0
# 50
; nock.compile { [50, 51] .0 }
# { [50, 51] (get 2) }
```

=== Shortcuts

For brevity, we use the following abbreviations:

```hclang
; .nasm nock.assemble;
; .nc nock.compile;
; .run { nock.eval (nasm _) }
; .pp { nock.print (nasm _) } # pretty-print
```

Where `_` is the default argument for a closure

This allows us to rewrite the initial example as:

```hclang
; run { [50, 51] (get 2) }
# 50
```

== OpCodes

nasm assigns names to each Nock opcode:

```hclang
.get 0
.quote 1
.map-reduce 2
.is-cell 3
.increment 4
.is-equal 5
```

=== Variable Expansion

You can define local variables that are expanded at assembly time

```hclang
; .list [10, 11, 12, 13];
; pp { list }
# `[10 [11 [12 13]]]`
```

Later we will show you how to define macros that are stored in the assembly
and evaluated at run time.

=== OpCode 0: get

The `get` opcode in nock extracts items from a binary tree
(which is what all lists are implemented as in nock)

```hclang
; run { list (get 2) }
# 10
; run { list (get 5) }
# [12, 13]
```

For convenience, you can pass `get` a 0-based cell instead of an atom
and it will calculate the index offset relative to the nested list:

```hclang
; .list2 [20, 21, [22, 23]];
; list2.0
# 20
; list2.2.1
# 23
; nc {list2 .2 .1}
# { [20, [21, [22, 23]]] (get [1, 1]) } # 7, I think
```

```hclang
```

```hclang
```

